Adrian Tamasa - atanasa@u-bordeaux.fr
Labri, bat A30, bureau 303
Cours: https://www.labri.fr/perso/atanasa/MPC

Etude de fondements logiques et mathÃ©matiques de l'informatique
    ThÃ©orie d'automates
    Logique mathÃ©matique, combinatoire

Notions clÃ©s:
    Automates finis
    Expressions rationnelles
    Grammaires algÃ©briques
    Automate Ã  pile
    ElÃ©ments de combinatoire

Plan:
    I   - Langages formels, mots
    II  - Expressions rationnelles
    III - Automates finis
    IV  - Grammaires algÃ©briques
    V   - Automates Ã  piles
    VI  - Quelques Ã©lÃ©ments introductifs de combinatoires



MOTS ET LANGAGES FORMELS

- Motivation pour l'Ã©tude des mots et langages

Toute donnÃ©e informatique est (codÃ©e par) un mot
Exemples du codage par les mots:
    Programme en C, texte
    Graphe

Mot = Suite de lettres
Langage formel = Ensemble de mots
Objectif: Comprendre, dÃ©finir, manipuler et transformer les langages
L'alphabet est un ensemble fini

Exemple: A alphabet, A = { 0, 1 }
Exemple de mots sur A: 01, 001101, Æ
Mot vide = Æ

A* = L'ensemble de mots formÃ©s sur l'alphabet A
A* est un monoÃ¯de libre
Le triplet (E, ., Æ) est un monoÃ¯de logique:
    - u.vâˆˆE
    - u.(v.w) = (u.v).w âˆ€u,v,wâˆˆE
    - u.Æ = Æ.u = u
Une partie P d'un monoÃ¯de est appelÃ©e base [A COMPLETER]
Un monoÃ¯de est libre s'il admet une base

Le langage vide Ã˜ est le langage qui ne contient aucun mot
Il ne faut pas confondre le langage vide Ã˜ avec le langage { Æ }

Longueur d'un mot = Nombre de lettres
Ex: |Æ| = 0, |010| = 3

ConcatÃ©nation de mots: consiste Ã  coller deux mots (u.v)
Ex: (aba).(bab) = ababab, Æ.(ab) = ab = (ab).Æ
Le mot vide est l'Ã©lÃ©ment neutre de l'opÃ©ration de concatÃ©nation



EXPRESSIONS RATIONNELLES (REGULIERES)

Une classe de langages a Ã©tÃ© dÃ©finie par Stephen C. Kleene (1909-1994)
Les langages rationnels (rÃ©guliers) sont dÃ©finis en utilisant les expressions rationnelles (rÃ©guliÃ¨res)

Les expressions rationnelles (rÃ©guliÃ¨res) sont formelles Ã  partir du mot vide et des lettres en utilisant 3 opÃ©rations rationnelles:
    L'union: L1UL2 := { u | uâˆˆL1 ou uâˆˆL2 } := L1+L2
        Ex: { a, ab } U { aa } = { a, ab, aa }
    Le produit (la concatÃ©nation): L1.L2 = { u1, u2 | u1âˆˆL1, u2âˆˆL2 }
        Ex: { a, ab } . { a } = { aa, aba } & { a, ab } . { a } != { a, ab, a }
    L'Ã©toile: L* := U(i>=0)Li = L0UL1UL2U... oÃ¹ L0 = { Æ }, L1 = L, L2 = L.L, L3 = L2.L, ..., Ln = Ln-1.L

Les expressions rationnelles sont construites Ã  partir de lettres, le mot vide Æ et l'expression vide Ã˜ en utilisant l'union (+), le produit (.) et l'Ã©toile (*).

L(e) = Langage dÃ©fini par l'expression e
Ex: L(a) = { a }, L(Æ) = { Æ }, L(Ã˜) = { Ã˜ }

On a:
    L(e1 + e2) = L(e1) + L(e2)
    L(e1 . e2) = L(e1) . L(e2)
    L(e*)      = (L(e))*

Exemples d'expressions rationnelles:
    Ensemble de mots sur { a, b } qui commencent par la lettre a: a . (a + b)*; a . (a* . b*)*
    Ensemble de mots sur { a, b } qui contiennent le facteur "aba": (a + b)* aba (a + b)*
    Ensemble des entiers divisibles par 2 en base 2 (l'alphabet est { 0, 1 }): (0 + 1)* 0
    Ensemble des entiers divisibles par 5, en base 10 (l'alphabet est { 0, 1, 2..., 9 }): (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)* (0 + 5)
    Ensemble de tous les mots sur A sauf le mot vide Æ: A* \ { Æ } = A . A* = A* . A

e+ := e . e* = e* . e = e . (Æ + e + eÂ² + ...) = e + eÂ² + eÂ³ + ...
e* := Æ + e+
Au niveau des langages, avec L langage rationnel
    L+ = L U LÂ² U LÂ³ U...
    L* = { Æ } U L U LÂ² U...
    Donc L* = { Æ } U L+



AUTOMATES FINIS

Un automate fini (AF) est une machine abstraite trÃ¨s simple qui permet de dÃ©finir des langages.
Un AF est une machine qui prend en entrÃ©e des mots et Ã©met un "verdict", chaque mot est acceptÃ© ou rejetÃ© par l'AF
IntÃ©rÃªt par rapport aux expressions: l'AF est un graphe (on a beaucoup d'algorithmes sur les graphes!)

Un automate fini est un quintuplet (A, Q, ğ›¿, I, F)
    A - L'alphabet de travail
    Q - L'ensemble d'Ã©tats
    ğ›¿ - L'ensemble de transitions, ğ›¿ âŠ† Q x A x Q
    I - L'ensemble d'Ã©tats initiaux, I âŠ† Q
    F - L'ensemble d'Ã©tats finaux/acceptants, F âŠ† Q

Une transition peut se reprÃ©senter de plusieurs faÃ§ons:
    - Triplet (Ex: (1, a, 2) avec 1, 2 âˆˆ Q et a âˆˆ A)
    - Couple  (Ex: ((1, a), 2))
    - FlÃ¨che orientÃ©e (1 --a-> 2)

M = { A = { a, b }, Q = { 1, 2, 3 }, I = { 1 }, F = { 2 } }
                  `
                 /
---> 1 ---a--> 2 -\
      `       /  \b
      a,b    /
        \   b
         \ ,
          3

ğ›¿ = { (1, a, 2), (2, b, 2), (2, b, 3), (3, a, 1), (3, b, 1) }
Un AF peut se reprÃ©senter de faÃ§on canonique sans la forme d'un graphe orientÃ© Ã©tiquetÃ©


Mots et langages acceptÃ©s par un AF

Un calcul (ou un run) d'un AF sur un mot a1a2...au (oÃ¹ a1...aU âˆˆ A) est un chemin formÃ© de transitions consÃ©cutives qui part d'un Ã©tat initial de l'AF
    1 --a-> 2                 calcul sur le mot "a"
    1 --a-> 2 --b-> 2 --b-> 2 calcul sur le mot "abb"
    1 ou 1 --Æ-> 1            calcul sur le mot Æ
Un calcul acceptant est un calcul qui termine dans un Ã©tat final
Un mot acceptÃ© (reconnu) par un AF est un mot pour lequel il existe au moins un calcul acceptant sur ce mot
    Le mot "abb" est un mot acceptÃ© (reconnu) par l'AF M
    Le mot "aa" n'est pas un mot acceptÃ© par l'AF M


Automates et matrices d'adjacences de graphes

On peut associer de faÃ§on canonique Ã  un automate la matrice d'adjacence du graphe respectif.
Mots de longueur k reconnus par l'AF
    Si on part d'un Ã©tat iâˆˆQ et on arrive dans un Ã©tat jâˆˆQ, M^k(ij)

Le langage acceptÃ©/reconnu par un automate H est l'ensemble des mots acceptÃ©s par l'automate H
    Notation: L(H) est le langage acceptÃ© par l'automate H
        L(M) = a(b + b(a + b)a)*
        Remarque: Il existe des algorithmes qui permettent d'exprimer Ã  l'aide d'une expressions rationnelle le langage acceptÃ© par un AF


Construction d'automates

Exercice: Construire un AF qui permet de reconnaÃ®tre les langages suivants sur l'alphabet A = { a, b }
1) L'ensemble des mots commenÃ§ant par "a"
2) L'ensemble des mots contenant "aba"
3) L'ensemble des mots qui contient un nombre pair de "a"
4) L'ensemble des mots qui ne contient ni "aa" ni "bb"

1) M1 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
   ğ›¿ = { (1, a, 2), (2, (a,b), 2) }
2) M2 = { A = { a, b }, Q = { 1, 2, 3, 4 }, I = { 1 }, F = { 4 } }
   ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, b, 3), (3, a, 4), (4, (a,b), 4) }
3) M3 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 1 } }
   ğ›¿ = { (1, a, 2), (1, b, 1), (2, b, 2), (2, a, 1) }
4) M4 = { A = { a, b }, Q = { 1, 2 }, I = { 1, 2 }, F = { 1, 2 } }
   ğ›¿ = { (1, a, 2), (2, b, 1) }

Automate sur l'alphabet Ã  10 lettres A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } qui reconnaÃ®t les nombres divisibles par 5
M4 = { A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
ğ›¿ = { (1, (0,1,2,3,4,5,6,7,8,9), 1), (1, (0,5), 2) }


Automate complet

Un AF H = (A, Q, ğ›¿, I, F) est un automate complet si pour chaque Ã©tat qâˆˆQ et pour chaque lettre aâˆˆA, il existe au moins une transition Ã©tiquetÃ©e par "a" sortant de l'Ã©tat q.