Adrian Tamasa - atanasa@u-bordeaux.fr
Labri, bat A30, bureau 303
Cours: https://www.labri.fr/perso/atanasa/MPC

Etude de fondements logiques et mathÃ©matiques de l'informatique
    ThÃ©orie d'automates
    Logique mathÃ©matique, combinatoire

Notions clÃ©s:
    Automates finis
    Expressions rationnelles
    Grammaires algÃ©briques
    Automate Ã  pile
    ElÃ©ments de combinatoire

Plan:
    I   - Langages formels, mots
    II  - Expressions rationnelles
    III - Automates finis
    IV  - Grammaires algÃ©briques
    V   - Automates Ã  piles
    VI  - Quelques Ã©lÃ©ments introductifs de combinatoires



MOTS ET LANGAGES FORMELS

- Motivation pour l'Ã©tude des mots et langages

Toute donnÃ©e informatique est (codÃ©e par) un mot
Exemples du codage par les mots:
    Programme en C, texte
    Graphe

Mot = Suite de lettres
Langage formel = Ensemble de mots
Objectif: Comprendre, dÃ©finir, manipuler et transformer les langages
L'alphabet est un ensemble fini

Exemple: A alphabet, A = { 0, 1 }
Exemple de mots sur A: 01, 001101, Æ
Mot vide = Æ

A* = L'ensemble de mots formÃ©s sur l'alphabet A
A* est un monoÃ¯de libre
Le triplet (E, ., Æ) est un monoÃ¯de logique:
    - u.vâˆˆE
    - u.(v.w) = (u.v).w âˆ€u,v,wâˆˆE
    - u.Æ = Æ.u = u
Une partie P d'un monoÃ¯de est appelÃ©e base [A COMPLETER]
Un monoÃ¯de est libre s'il admet une base

Le langage vide Ã˜ est le langage qui ne contient aucun mot
Il ne faut pas confondre le langage vide Ã˜ avec le langage { Æ }

Longueur d'un mot = Nombre de lettres
Ex: |Æ| = 0, |010| = 3

ConcatÃ©nation de mots: consiste Ã  coller deux mots (u.v)
Ex: (aba).(bab) = ababab, Æ.(ab) = ab = (ab).Æ
Le mot vide est l'Ã©lÃ©ment neutre de l'opÃ©ration de concatÃ©nation



EXPRESSIONS RATIONNELLES (REGULIERES)

Une classe de langages a Ã©tÃ© dÃ©finie par Stephen C. Kleene (1909-1994)
Les langages rationnels (rÃ©guliers) sont dÃ©finis en utilisant les expressions rationnelles (rÃ©guliÃ¨res)

Les expressions rationnelles (rÃ©guliÃ¨res) sont formelles Ã  partir du mot vide et des lettres en utilisant 3 opÃ©rations rationnelles:
    L'union: L1 âˆª L2 := { U | uâˆˆL1 ou uâˆˆL2 } := L1+L2
        Ex: { a, ab } âˆª { aa } = { a, ab, aa }
    Le produit (la concatÃ©nation): L1.L2 = { u1, u2 | u1âˆˆL1, u2âˆˆL2 }
        Ex: { a, ab } . { a } = { aa, aba } & { a, ab } . { a } != { a, ab, a }
    L'Ã©toile: L* := U(i>=0)Li = L0 âˆª L1 âˆª L2 âˆª... oÃ¹ L0 = { Æ }, L1 = L, L2 = L.L, L3 = L2.L, ..., Ln = Ln-1.L

Les expressions rationnelles sont construites Ã  partir de lettres, le mot vide Æ et l'expression vide Ã˜ en utilisant l'union (+), le produit (.) et l'Ã©toile (*).

L(e) = Langage dÃ©fini par l'expression e
Ex: L(a) = { a }, L(Æ) = { Æ }, L(Ã˜) = { Ã˜ }

On a:
    L(e1 + e2) = L(e1) + L(e2)
    L(e1 . e2) = L(e1) . L(e2)
    L(e*)      = (L(e))*

Exemples d'expressions rationnelles:
    Ensemble de mots sur { a, b } qui commencent par la lettre a: a . (a + b)*; a . (a* . b*)*
    Ensemble de mots sur { a, b } qui contiennent le facteur "aba": (a + b)* aba (a + b)*
    Ensemble des entiers divisibles par 2 en base 2 (l'alphabet est { 0, 1 }): (0 + 1)* 0
    Ensemble des entiers divisibles par 5, en base 10 (l'alphabet est { 0, 1, 2..., 9 }): (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)* (0 + 5)
    Ensemble de tous les mots sur A sauf le mot vide Æ: A* \ { Æ } = A . A* = A* . A

e+ := e . e* = e* . e = e . (Æ + e + eÂ² + ...) = e + eÂ² + eÂ³ + ...
e* := Æ + e+
Au niveau des langages, avec L langage rationnel
    L+ = L âˆª LÂ² âˆª LÂ³ âˆª...
    L* = { Æ } âˆª L âˆª LÂ² âˆª...
    Donc L* = { Æ } âˆª L+



AUTOMATES FINIS

Un automate fini (AF) est une machine abstraite trÃ¨s simple qui permet de dÃ©finir des langages.
Un AF est une machine qui prend en entrÃ©e des mots et Ã©met un "verdict", chaque mot est acceptÃ© ou rejetÃ© par l'AF
IntÃ©rÃªt par rapport aux expressions: l'AF est un graphe (on a beaucoup d'algorithmes sur les graphes!)

Un automate fini est un quintuplet (A, Q, ğ›¿, I, F)
    A - L'alphabet de travail
    Q - L'ensemble d'Ã©tats
    ğ›¿ - L'ensemble de transitions, ğ›¿ âŠ† Q x A x Q
    I - L'ensemble d'Ã©tats initiaux, I âŠ† Q
    F - L'ensemble d'Ã©tats finaux/acceptants, F âŠ† Q

Une transition peut se reprÃ©senter de plusieurs faÃ§ons:
    - Triplet (Ex: (1, a, 2) avec 1, 2âˆˆQ et aâˆˆA)
    - Couple  (Ex: ((1, a), 2))
    - FlÃ¨che orientÃ©e (1 --a-> 2)

M = { A = { a, b }, Q = { 1, 2, 3 }, I = { 1 }, F = { 2 } }
                  `
                 /
---> 1 ---a--> 2 -\
      `       /  \b
      a,b    /
        \   b
         \ ,
          3

ğ›¿ = { (1, a, 2), (2, b, 2), (2, b, 3), (3, a, 1), (3, b, 1) }
Un AF peut se reprÃ©senter de faÃ§on canonique sans la forme d'un graphe orientÃ© Ã©tiquetÃ©


Mots et langages acceptÃ©s par un AF

Un calcul (ou un run) d'un AF sur un mot a1a2...au (oÃ¹ a1...au âˆˆ A) est un chemin formÃ© de transitions consÃ©cutives qui part d'un Ã©tat initial de l'AF
    1 --a-> 2                 calcul sur le mot "a"
    1 --a-> 2 --b-> 2 --b-> 2 calcul sur le mot "abb"
    1 ou 1 --Æ-> 1            calcul sur le mot Æ
Un calcul acceptant est un calcul qui termine dans un Ã©tat final
Un mot acceptÃ© (reconnu) par un AF est un mot pour lequel il existe au moins un calcul acceptant sur ce mot
    Le mot "abb" est un mot acceptÃ© (reconnu) par l'AF M
    Le mot "aa" n'est pas un mot acceptÃ© par l'AF M


Automates et matrices d'adjacences de graphes

On peut associer de faÃ§on canonique Ã  un automate la matrice d'adjacence du graphe respectif.
Mots de longueur k reconnus par l'AF
    Si on part d'un Ã©tat iâˆˆQ et on arrive dans un Ã©tat jâˆˆQ, M^k(ij)

Le langage acceptÃ©/reconnu par un automate H est l'ensemble des mots acceptÃ©s par l'automate H
    Notation: L(H) est le langage acceptÃ© par l'automate H
        L(M) = a(b + b(a + b)a)*
        Remarque: Il existe des algorithmes qui permettent d'exprimer Ã  l'aide d'une expressions rationnelle le langage acceptÃ© par un AF


Construction d'automates

Exercice: Construire un AF qui permet de reconnaÃ®tre les langages suivants sur l'alphabet A = { a, b }
1) L'ensemble des mots commenÃ§ant par "a"
2) L'ensemble des mots contenant "aba"
3) L'ensemble des mots qui contient un nombre pair de "a"
4) L'ensemble des mots qui ne contient ni "aa" ni "bb"

1) M1 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
   ğ›¿ = { (1, a, 2), (2, (a,b), 2) }
2) M2 = { A = { a, b }, Q = { 1, 2, 3, 4 }, I = { 1 }, F = { 4 } }
   ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, b, 3), (3, a, 4), (4, (a,b), 4) }
3) M3 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 1 } }
   ğ›¿ = { (1, a, 2), (1, b, 1), (2, b, 2), (2, a, 1) }
4) M4 = { A = { a, b }, Q = { 1, 2 }, I = { 1, 2 }, F = { 1, 2 } }
   ğ›¿ = { (1, a, 2), (2, b, 1) }

Automate sur l'alphabet Ã  10 lettres A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } qui reconnaÃ®t les nombres divisibles par 5
M4 = { A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
ğ›¿ = { (1, (0,1,2,3,4,5,6,7,8,9), 1), (1, (0,5), 2) }



AUTOMATE COMPLET

DÃ©finition: Un AF H = (A, Q, I, F, ğ›¿) est un automate complet si pour chaque Ã©tat qâˆˆQ et pour chaque lettre aâˆˆA, il existe au moins une transition Ã©tiquetÃ©e par a sortant de l'Ã©tat q


Construction d'un automate complet (le complÃ©tÃ©)

ThÃ©orÃ¨me: Si H = (A, Q, I, F, ğ›¿) et soit J = (A, Q âˆª { q1 }, I, F, ğ›¿') oÃ¹:
    q1 est un nouveau Ã©tat (Ã©tat puit?)
    Les transitions de J sont donnÃ©es par ğ›¿' = ğ›¿ âˆª { (p, Î±, q1) } pâˆˆQ, Î±âˆˆA et il n'y a pas de transition de la forme (p, Î±, q) dans H [A completer...?]
L'AF J est un automate complet et L(H) = L(J)
J est le complÃ©tÃ© de H

Preuve: ImmÃ©diate, car les transitions rajoutÃ©es ne modifient pas les chemins associÃ©s aux mots reconnus



AUTOMATES DETERMINISTES

DÃ©finition: L'automate H = (A, Q, I, F, ğ›¿) est un AF dÃ©terministe (ou AFD) si:
    |I| = 1 (il existe un seul Ã©tat initial)
    Pour tout pâˆˆQ et toute Î±âˆˆA, il existe au plus une transition Ã©tiquetÃ©e Î± qui soit de l'Ã©tat p.


Le complÃ©mentaire

DÃ©finition: Le complÃ©mentaire (ou le complÃ©ment) d'un ensemble de mots L âŠ† A* est l'ensemble A* \ L (l'ensemble de mots qui ne sont pas dans L)

ThÃ©orÃ¨me: Soit H = (A, Q, I, F, ğ›¿) un automate complet et dÃ©terministe. Soit J = (A, Q, I, Q \ F, ğ›¿) (J est obtenu Ã  partir de H en rendant finaux les Ã©tats non-finaux de H)
Alors, L(J) = A* \ L(H)

Exemple: H = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, a, 2), (2, a, 2) } } - L(H) = aa* = a+
         J = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, a, 2), (2, a, 2) } } - L(J) = { Æ } = A* \ L(H)

Remarque: Si A n'est pas complet et dÃ©terministe, le thÃ©orÃ¨me n'est pas vrai

Exemples:
    Automate complet mais pas dÃ©terministe:
        H = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, (a,b), 2) } } - L(H) = (a + b)* a (a + b*)
        J = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, (a,b), 2) } } - L(J) = (a + b)* = A* â‰  A* \ L(H)
    Automate dÃ©terministe mais pas complet:
        H = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, a, 2) } - L(H) = a
        J = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, a, 2) } - L(J) = { Æ } â‰  A* \ L(H)

Remarque: Il ne faut pas confondre complÃ©menter et complÃ©ter



DETERMINISATION DES AUTOMATES

Objectif: A partir d'un AF non-dÃ©terministe H, construire un automate dÃ©terministe J tel que L(A) = L(B)


RÃ©sultat prÃ©liminaire - ensemble de sous-ensembles

Soit Q un ensemble fini, |Q| = n. On note 2^Q l'ensemble de sous-ensembles de Q. Alors |2^Q| = 2^n
Q = { q1, q2,... qn }  2^Q = { âˆ…, { q1 }, { q2 }, ..., { qn }, { q1, q2 }, { q1, q3 }, ..., { qn-1, qn }, ..., { q1, q2, ..., qn } }
Si n = 3, 2^Q = { âˆ…, { q1 }, { q2 }, { q3 }, { q1, q2 }, { q1, q3 }, { q2, q3 }, { q1, q2, q3 } }
|2^Q| = 2^3 = 8

Preuve: |2^Q| = (n 0) + (n 1) + ... (n n) = 2^n oÃ¹ (n k) = (n!) / (k!(n-k)!)


La mÃ©thode de sous-ensembles

ThÃ©orÃ¨me: Soit H = (A, Q, I, F, ğ›¿) un AF non-dÃ©terministe
On construit l'automate pour lequel:
    l'ensemble d'Ã©tats est 2^Q
    l'Ã©tat initial est { I }
    un Ã©tat Pâˆˆ2^Q est final si et seulement si P âˆ© F â‰  âˆ…
    la fonction de transition est donnÃ©e par ğ›¿J(P, a) = U(pâˆˆP) ğ›¿(p, a), âˆ€Pâˆˆ2^Q, aâˆˆA
ThÃ©orÃ¨me: L'AF construit ainsi est un AFD qui reconnait le mÃªme langage que A

Exemple: H = { A = { a, b }, Q = { p, q, r }, I = { p }, F = { r }, ğ›¿ = { (p, (a,b), p), (p, a, q), (q, b, r), (r, (a,b), r) } }
    Q = { p, q, r }
    Les sous-ensembles de Q QJ = { âˆ…, { p }, { q }, { r }, { p, q }, { p, r }, { q, r }, { p, q, r } }
    IJ = { p }
    FJ = { { r }, { p, r }, { q, r }, { p, q, r } }
    ğ›¿J({ p }, a) = ğ›¿H(p, a) = { p, q }
    ğ›¿J({ p }, b) = ğ›¿H(p, b) = { p }
    ğ›¿J({ q }, a) = ğ›¿H(q, a) = âˆ…
    ğ›¿J({ q }, b) = ğ›¿H(q, b) = { r }
    ğ›¿J({ r }, a) = ğ›¿H(r, a) = { r }
    ğ›¿J({ r }, b) = ğ›¿H(r, b) = { r }
    ğ›¿J({ p, q }, a) = ğ›¿H(p, a) U ğ›¿H(q, a) = { p, q } U âˆ…    = { p, q }
    ğ›¿J({ p, q }, b) = ğ›¿H(p, b) U ğ›¿H(q, b) = { p } U { r }    = { p, r }
    ğ›¿J({ q, r }, a) = ğ›¿H(q, a) U ğ›¿H(r, a) = âˆ… U { r }       = { r }
    ğ›¿J({ q, r }, b) = ğ›¿H(q, b) U ğ›¿H(r, b) = { r } U { r }    = { r }
    ğ›¿J({ p, r }, a) = ğ›¿H(p, a) U ğ›¿H(r, a) = { p, q } U { r } = { p, q, r }
    ğ›¿J({ p, r }, b) = ğ›¿H(p, b) U ğ›¿H(r, b) = { p } U { r }    = { p, r }
    ğ›¿J({ p, q, r }, a) = ğ›¿H(p, a) U ğ›¿H(q, a) U ğ›¿H(r, a) = { p, q } U âˆ… U { r } = { p, q, r }
    ğ›¿J({ p, q, r }, b) = ğ›¿H(p, b) U ğ›¿H(q, b) U ğ›¿H(r, b) = { p } U { r } U { r } = { p, r }
    [VOIR SCHEMA]

Preuve: L'AF J est dÃ©terministe et complet par construction.
    RÃ©-Ã©criture de transitions dans J
    P, RâŠ‚Q, aâˆˆA on a P--a->R lorsque R = { qâˆˆQ | âˆƒpâˆˆP, (p, a, q)âˆˆğ›¿H }

Lemme: Pour tout mot w et pour tout Ã©tat râˆˆQ, il existe un chemin q--w->r dans H avec qâˆˆI
    si et seulement s'il existe un chemin I--w->R dans J, avec râˆˆR
    L(H) = L(J) <=> L(H)âŠ†L(J) et L(J)âŠ†L(H) (tout mot de L(H) est tout mot de L(J))
    Soit wâˆˆL(H), il existe un chemin acceptant dans H sur w, c'est Ã  dire âˆƒqâˆˆI et râˆˆF tel que q--w->r dans H

D'aprÃ¨s le lemme, il existe un chemin I--w->R dans J, avec râˆˆR mais râˆˆF => Râˆ©Fâ‰ âˆ… => R Ã©tat final de J
    => I--w->R est un chemin acceptant
    => wâˆˆL(J), âˆ€w
    => L(H)âŠ†L(J)
    => L(J)âŠ†L(H)

Soit wâˆˆL(J)
    => Il existe un chemin acceptant dans J sur w
    C'est Ã  dire âˆƒ I--w->R dans J, R Ã©tat final
        => âˆƒrâˆˆF tel que râˆˆR (car Râˆ©Fâ‰ âˆ…)

D'aprÃ¨s le lemme, il existe un calcul q--w->r dans H, avec qâˆˆI
    => wâˆˆL(H), âˆ€w
    => L(J)âŠ†L(H)
    => L(H) = L(J)


PropriÃ©tÃ©s de clotures des AF

DÃ©finition: Un langage reconnaissable est un langage pour lequel il existe un AF qui reconnaÃ®t ce langage

ThÃ©orÃ¨me: Soit A un alphabet
    - Si L âŠ† A* est un langage reconnaissable alors son complÃ©mentaire A*\L est aussi reconnaissable
    - Si L1 et L2 sont des langages reconnaissables, alors les langages L1âˆªL2 et L1âˆ©L2 sont aussi reconnaissables

Soit Hi = (A, Qi, Ii, Fi, ğ›¿i) avec i = 1,2, Q = Q1 x Q2, I = I1 x I2,
Fâˆª = { (q1, q2)âˆˆQ | q1âˆˆF1 ou q2âˆˆF2 }
Fâˆ© = { (q1, q2)âˆˆQ | q1âˆˆF1 et q2âˆˆF2 } = F1 x F2
ğ›¿ = { ((p1, p2), a, (q1, q2))âˆˆQ x A x Q | (pi, a, qi)âˆˆğ›¿i, i = 1,2 }

ThÃ©orÃ¨me - Produit cartÃ©sien d'AF
    - L'AF Hâˆ© = (A, Q, I, Fâˆ©, ğ›¿) reconnait l'intersection des langages reconnus par H1 et H2
    - Si H1 et H2 sont complets, l'AF Hâˆª = (A, Q, I, Fâˆª, ğ›¿) reconnait l'union des langages reconnus par H1 et H2

Preuve:
    1) L(H1)âˆ©L(H2) = L(Hâˆ©) <=> L(H1)âˆ©L(H2) âŠ† L(Hâˆ©) et L(Hâˆ©) âŠ† L(H1)âˆ©L(H2)
        1) L(H1)âˆ©L(H2) âŠ† L(Hâˆ©)
            Soit w = a1a2...anâˆˆL(H1)âˆ©L(H2)
            => âˆƒp0--a1->p1--a2->...--an->pn calcul acceptant dans H1
               âˆƒq0--a1->q1--a2->...--an->qn calcul acceptant dans H2
            => (p0, q0)--a1->(p1, q1)--a2->...--an->(pn, qn) calcul dans Hâˆ©
               p0âˆˆI1, q0âˆˆI2 => (p0, q0)âˆˆI
               pnâˆˆF1, qnâˆˆF2 => (pn, qn)âˆˆFâˆ©
            => wâˆˆL(Aâˆ©) => L(H1)âˆ©L(H2) âŠ† L(Hâˆ©)
        2) L(Hâˆ©) âŠ† L(H1)âˆ©L(H2)
            Soit w = a1a2...anâˆˆL(Hâˆ©)
            => âˆƒ(p0, q0)--a1->(p1, q1)--a2->...--an->(pn, qn) calcul acceptant dans Hâˆ©
            => (p0, q0)âˆˆI  => p0âˆˆI1, q0âˆˆI2
               (pn, qn)âˆˆFâˆ© => pnâˆˆF1, qnâˆˆF2
               p0--a1->p1--a2->...--an->pn calcul dans H1
               q0--a1->q1--a2->...--an->qn calcul dans H2
            => wâˆˆL(H1)âˆ©L(H2) => L(Hâˆ©) âŠ† L(H1)âˆ©L(H2)
        => L(H1)âˆ©L(H2) = L(Hâˆ©)
    2) L(H1)âˆªL(H2) = L(Aâˆª) <=> L(H1)âˆªL(H2) âŠ† L(Hâˆª) et L(Hâˆª) âŠ† L(H1)âˆªL(H2)
        1) L(H1)âˆªL(H2) âŠ† L(Hâˆª)
            Soit w = a1a2...anâˆˆL(H1)âˆªL(H2) => w reconnu par H1, soit par H2
            On suppose (sans perte de gÃ©nÃ©ralitÃ©) que wâˆˆL(H1)
            => âˆƒp0--a1->p1--a2->...--an->pn calcul acceptant dans H1
               p0âˆˆI1, pnâˆˆF1
            H2 est complet: âˆƒq0--a1->q1--a2->...--an->qn calcul dans H2 avec q0âˆˆI2
            => (p0, q0)--a1->(p1, q1)--a2->...--an->(pn, qn) calcul dans Hâˆª
            (p0, q0)âˆˆI, (pn, qn)âˆˆFâˆª
            => wâˆˆL(Hâˆª) => L(H1)âˆªL(H2) âŠ† L(Hâˆª)
        2) Identique au cas 1.2

Exemple de produit cartÃ©sien d'AF (VOIR FIG. 1)
    H1: { A = { a, b }, Q = { q1, q2, q3 }, I = { q1 }, F = { q3 }, ğ›¿ = { (q1, (a,b), q1), (q1, b, q2), (q2, a, q3), (q3, (a,b), q3) } }
    H2: { A = { a, b }, Q = { q4, q5, q6 }, I = { q4 }, F = { q6 }, ğ›¿ = { (q4, (a,b), q4), (q4, a, q5), (q5, b, q6), (q6, (a,b), q6) } }

    Trouver le produit cartÃ©sien de H1 et H2, afin d'avoir un AF qui reconnait L(H1)âˆ©L(H2)

    Hâˆ© = {
        A = { a, b }, I = { (q1, q4) }, Fâˆ© = { (q3, q6) },
        Q = { (q1, q4), (q1, q5), (q1, q6), (q2, q4), (q2, q5), (q2, q6), (q3, q4), (q3, q5), (q3, q6) },
        ğ›¿ = {
            ((q1, q4), (a,b), (q1, q4)), // 14 -> 14
            ((q1, q6), (a,b), (q1, q6)), // 16 -> 16
            ((q3, q4), (a,b), (q3, q4)), // 34 -> 34
            ((q3, q6), (a,b), (q3, q6)), // 36 -> 36

            ((q1, q4), a,     (q1, q5)), // 14 -> 15
            ((q1, q5), b,     (q1, q6)), // 15 -> 16
            ((q1, q5), b,     (q2, q6)), // 15 -> 26
            ((q1, q6), b,     (q2, q6)), // 16 -> 26
            ((q2, q6), a,     (q3, q6)), // 26 -> 36

            ((q1, q4), b,     (q2, q4)), // 14 -> 24
            ((q2, q4), a,     (q3, q4)), // 24 -> 34
            ((q2, q4), a,     (q3, q5)), // 24 -> 35
            ((q3, q4), a,     (q3, q5)), // 34 -> 35
            ((q3, q5), b,     (q3, q6))  // 35 -> 36
        }
    }

AF avec Æ-transitions
    Identiques aux AF, mais il peut aussi y avoir des transitions sur le mot vide Æ

Exemple
    H = { A = { a, b }, Q = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, I = { 1 }, F = { 9 }, ğ›¿ = { (1, Æ, 2), (1, Æ, 8), (2, Æ, 3), (2, Æ, 5), (3, a, 4), (4, Æ, 7), (5, b, 6), (6, Æ, 7), (7, Æ, 2), (7, Æ, 8), (8, a, 9) } }
    L(H) - L'ensemble des mots finissant par "a"

ThÃ©orÃ¨me de Kleene
    On peut convertir d'une maniÃ¨re algorithmique une expression rationnelle en AF qui reconnait le mÃªme langage
    Vice-versa, on peut convertir de maniÃ¨re algorithmique un AF en expression rationnelle qui dÃ©crit le langage reconnu par l'AF



EXPRESSIONS -> AUTOMATES
IntÃ©rÃªt : on peut manipuler les AF par des algorithmes de graphes.


==> Algorithme de Thompson <==
On peut construire pour chaque expression rationnelle un AF avec Æ-transition qui reconnaÃ®t le mÃªme langage que l'expression 

-> PropriÃ©tÃ©s <-
l'AF construit par l'algo de Thompson :
- A un unique Ã©tat initial sur lequel n'arrive aucune transition
- A un unique Ã©tat final duquel ne part aucune transition

-> Algo rÃ©cursif <-
En supposant qu'on sait faire des automates qui reconnaissent les expressions e1 et e2, on en fait pour e1.e2, e1+e2 et e1*
Algorithme de Thompson pour les langages rationnels "de base" :
i) Ã˜ :         ->(1)     (2)->       langage reconnu : Ã˜ 
ii) {Æ} :      ->(1)--Æ->(2)->       langage reconnu : {Æ} 
iii) {a} :       ->(1)--a->(2)->       langage reconnu : {a} 

=> A) L'Union
On a A1 et A2 des AF tq L(A1) = e1 et L(A2) = e2  =>  L(A) = e1+e2
A:

        __________A1___________
      /                         \
        (i1) - - - - - - - (f1)
        /                    \
       Æ                      Æ
      /                        \
--->(i)                        (f)--->
      \                        /
       Æ                      Æ
        \                    /   \
        (i2) - - - - - - - (f2)   | A2
                                 /

=> B) Le produit
On a A1 et A2 des AF tq L(A1) = e1 et L(A2) = e2  =>  L(A) = e1.e2
A:
      ______A1______         ______A2_____
--->(i1) - - - - (f1)--Æ-->(i2) - - - - (f2)---->
 


=> C) L'Ã©toile (de la mort lol)
On a A1 un AF tq L(A1) = e1  =>  L(A) = e1*
A:
      _________>____Æ_____>__________
     /                               \
--->(i)---Æ-->(i1) - - - - (f1)---Æ-->(f)--->
                \____<__Æ__/


-> Remarques <-
- Les Æ-transitions peuvent ensuite Ãªtre enlevÃ©e pour avoir des AF sans Æ-transition qui reconnaissent les mÃªmes langages
- Les Æ-transitions ne sont pas initiales Ã  ce stade, identifier les Ã©tats initiaux et finaux sans prÃ©cautions peut mener Ã  des AF qui ne reconnaissent pas le langage recherchÃ©.

-> Principal inconvÃ©nient de l'algo de Thompson <-
Il introduit beaucoup d'Æ-transitions

==> Algorithme de Glushkov <==
Conversion des expressions rationnelles en AF sans Æ-transition.
Input : une expression rationnelle

I) On commence par renommer les lettres de l'expressions afin d'avoir des noms uniques : linÃ©arisation.
    ex: a(ab+b*)*b  ->  a1(a2b1+b2*)*b3
II) Chaque Ã©tat de l'AF correspondra Ã  une nouvelle lettre.
III) On rajoute un Ã©tat supplÃ©mentaire, l'Ã©tat Æ (ou 0), qui sera le seul Ã©tat initial de l'AF.
IV) Les transitions depuis l'Ã©tat Æ vont aller vers les Ã©tats ai dont les lettres peuvent commencer un mot du langage. (Æ)-->(ai)
V) Il existe une transition de l'Ã©tat ai vers bj (ai)--->(bj) si il existe un mot du langage qui contient le facteur "aibj".
VI) Les transitions allant Ã  un Ã©tat quelconque sont Ã©tiquetÃ©es par la lettre de l'Ã©tat respectif.
VII) Les Ã©tats finaux sont les Ã©tats Ã©tiquetÃ©s par les lettres qui peuvent terminer un mot du langage.




AUTOMATES -> EXPRESSIONS

Il existe plusieurs algorithmes pour convertir un AF en expression:
    Algorithmes de Brzozowski
    Lemme d'Arden
    etc

Lemme d'Arden
    Dean N Arden, 1961
    Il permet de rÃ©soudre des Ã©quations dont les inconnues (et les constantes) sont des langages
    Le lemme permet de calculer Ã  partir d'un AF une expression rationnelle
    Soit U et V deux lanages tel que Æâˆ‰U,V
    Alors le seul langage X tel que X = UX+V est U*V

Exemple: Soit l'AF H = { A = { 0, 1 }, Q = { 1, 2, 3 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, 0, 1), (1, 1, 2), (2, 1, 1), (2, 0, 3), (3, 1, 3), (3, 0, 2) } (VOIR ANNEXE [A COMPLETER])
         Utiliser le lemme d'Arden pour trouver le langage reconnu par cet automate
         Etat 0: X0 = 0X0 + 1X1 + Æ
         Etat 1: X1 = 0X2 + 1X0
         Etat 2: X2 = 0X1 + 1X2
         (2) => X2 = 1* 0X1
         (1) => X1 = 0 1* 0X1 + 1X0
         Arden => X1 = (0 1* 0)* 1X0
         (0) => X0 = 0X0 + 1 ((0 1* 0)* 1X0) + Æ
                X0 = (0 + 1 (0 1* 0)* 1)X0 + Æ
         Arden => X0 = (0 + 1 (0 1* 0)* 1)* Æ
                X0 = (0 + 1 (0 1* 0)* 1)*
         Le langage reconnu par l'AF est X0

Preuve du lemme d'Ardun
    X = UX+V <==> X = U*V
        <= UX+V = U(U*V) + V
                = (UU* + Æ) V
                = U*V = X
        => Pour montrer que X = U*V on doit montrer:
            U*V âŠ† X
                X = UX+V => V âŠ† X (a) et UX âŠ† X (b)
                On doit montrer que U*V âŠ† X c'est Ã  dire Hn = U^nV âŠ† X âˆ€nâ‰¥0
                On montre cela par rÃ©currence sur n
                H0: U^0V = ÆV = V âŠ† X (d'aprÃ¨s a)
                Hn -> Hn+1: Soit U^nV âŠ† X alors U^(n+1)V âŠ† X
                    U^(n+1)V = U(U^nV)
                             âŠ† UX (d'aprÃ¨s Hn)
                             âŠ† X  (d'aprÃ¨s b)
                Vrai
            X âŠ† U*V
                On suppose qu'il existe xâˆˆX tel que xâˆ‰U*V
                On choisit X de longueur minimale
                xâˆˆX = UX+V
                -> Soit xâˆˆV: alors xâˆˆU*V => Contradiction
                -> Soit xâˆˆUX:
                    x = ux', uâˆˆU et x'âˆˆX
                    Æâˆ‰U => uâ‰ Æ => |u|â‰¥1 => |x'|<|x|
                    x'âˆˆU*V => x = ux'âˆˆUU*V = U*V => Contradiction
                Vrai par l'absurde

Exemple: Soit l'AF H = { A = { 0, 1 }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, 1, 1), (1, 0, 2), (2, 0, 1), (2, 1, 2) } (VOIR ANNEXE [A COMPLETER])
         Utiliser le lemme d'Arden pour trouver le langage reconnu par l'AF
         Etat 1: 0X2 + 1X1 + Æ
         Etat 2: 0X1 + 1X2
         (2) => X2 = 1* 0X1
         (1) => X1 = 1X1 + 0 1* 0X1
                X1 = (1 + 0 1* 0)X1
         Arden => X1 = (1 + 0 1* 0)*Æ
                X1 = (1 + 0 1* 0)*
         Le langage reconnu par l'AF est X1


RESIDUELS

DÃ©finition: On appelle un rÃ©siduel (ou quotient Ã  gauche) d'un langage LcA* par rapport Ã  un mot uâˆˆA* le langage u^-1L = L/u = { vâˆˆA* | uvâˆˆL }
Bref c'est lâ€™ensemble des mots de L qui commencent par u auxquels on a retirÃ© ce prÃ©fixe u.