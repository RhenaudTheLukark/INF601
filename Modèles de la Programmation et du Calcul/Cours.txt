Adrian Tamasa - atanasa@u-bordeaux.fr
Labri, bat A30, bureau 303
Cours: https://www.labri.fr/perso/atanasa/MPC

Etude de fondements logiques et mathÃ©matiques de l'informatique
    ThÃ©orie d'automates
    Logique mathÃ©matique, combinatoire

Notions clÃ©s:
    Automates finis
    Expressions rationnelles
    Grammaires algÃ©briques
    Automate Ã  pile
    ElÃ©ments de combinatoire

Plan:
    I   - Langages formels, mots
    II  - Expressions rationnelles
    III - Automates finis
    IV  - Grammaires algÃ©briques
    V   - Automates Ã  piles
    VI  - Quelques Ã©lÃ©ments introductifs de combinatoires



MOTS ET LANGAGES FORMELS

- Motivation pour l'Ã©tude des mots et langages

Toute donnÃ©e informatique est (codÃ©e par) un mot
Exemples du codage par les mots:
    Programme en C, texte
    Graphe

Mot = Suite de lettres
Langage formel = Ensemble de mots
Objectif: Comprendre, dÃ©finir, manipuler et transformer les langages
L'alphabet est un ensemble fini

Exemple: A alphabet, A = { 0, 1 }
Exemple de mots sur A: 01, 001101, Æ
Mot vide = Æ

A* = L'ensemble de mots formÃ©s sur l'alphabet A
A* est un monoÃ¯de libre
Le triplet (E, ., Æ) est un monoÃ¯de logique:
    - u.vâˆˆE
    - u.(v.w) = (u.v).w âˆ€u,v,wâˆˆE
    - u.Æ = Æ.u = u
Une partie P d'un monoÃ¯de est appelÃ©e base [A COMPLETER]
Un monoÃ¯de est libre s'il admet une base

Le langage vide Ã˜ est le langage qui ne contient aucun mot
Il ne faut pas confondre le langage vide Ã˜ avec le langage { Æ }

Longueur d'un mot = Nombre de lettres
Ex: |Æ| = 0, |010| = 3

ConcatÃ©nation de mots: consiste Ã  coller deux mots (u.v)
Ex: (aba).(bab) = ababab, Æ.(ab) = ab = (ab).Æ
Le mot vide est l'Ã©lÃ©ment neutre de l'opÃ©ration de concatÃ©nation



EXPRESSIONS RATIONNELLES (REGULIERES)

Une classe de langages a Ã©tÃ© dÃ©finie par Stephen C. Kleene (1909-1994)
Les langages rationnels (rÃ©guliers) sont dÃ©finis en utilisant les expressions rationnelles (rÃ©guliÃ¨res)

Les expressions rationnelles (rÃ©guliÃ¨res) sont formelles Ã  partir du mot vide et des lettres en utilisant 3 opÃ©rations rationnelles:
    L'union: L1 âˆª L2 := { U | uâˆˆL1 ou uâˆˆL2 } := L1+L2
        Ex: { a, ab } âˆª { aa } = { a, ab, aa }
    Le produit (la concatÃ©nation): L1.L2 = { u1, u2 | u1âˆˆL1, u2âˆˆL2 }
        Ex: { a, ab } . { a } = { aa, aba } & { a, ab } . { a } != { a, ab, a }
    L'Ã©toile: L* := U(i>=0)Li = L0 âˆª L1 âˆª L2 âˆª... oÃ¹ L0 = { Æ }, L1 = L, L2 = L.L, L3 = L2.L, ..., Ln = Ln-1.L

Les expressions rationnelles sont construites Ã  partir de lettres, le mot vide Æ et l'expression vide Ã˜ en utilisant l'union (+), le produit (.) et l'Ã©toile (*).

L(e) = Langage dÃ©fini par l'expression e
Ex: L(a) = { a }, L(Æ) = { Æ }, L(Ã˜) = { Ã˜ }

On a:
    L(e1 + e2) = L(e1) + L(e2)
    L(e1 . e2) = L(e1) . L(e2)
    L(e*)      = (L(e))*

Exemples d'expressions rationnelles:
    Ensemble de mots sur { a, b } qui commencent par la lettre a: a . (a + b)*; a . (a* . b*)*
    Ensemble de mots sur { a, b } qui contiennent le facteur "aba": (a + b)* aba (a + b)*
    Ensemble des entiers divisibles par 2 en base 2 (l'alphabet est { 0, 1 }): (0 + 1)* 0
    Ensemble des entiers divisibles par 5, en base 10 (l'alphabet est { 0, 1, 2..., 9 }): (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)* (0 + 5)
    Ensemble de tous les mots sur A sauf le mot vide Æ: A* \ { Æ } = A . A* = A* . A

e+ := e . e* = e* . e = e . (Æ + e + eÂ² + ...) = e + eÂ² + eÂ³ + ...
e* := Æ + e+
Au niveau des langages, avec L langage rationnel
    L+ = L âˆª LÂ² âˆª LÂ³ âˆª...
    L* = { Æ } âˆª L âˆª LÂ² âˆª...
    Donc L* = { Æ } âˆª L+



AUTOMATES FINIS

Un automate fini (AF) est une machine abstraite trÃ¨s simple qui permet de dÃ©finir des langages.
Un AF est une machine qui prend en entrÃ©e des mots et Ã©met un "verdict", chaque mot est acceptÃ© ou rejetÃ© par l'AF
IntÃ©rÃªt par rapport aux expressions: l'AF est un graphe (on a beaucoup d'algorithmes sur les graphes!)

Un automate fini est un quintuplet (A, Q, ğ›¿, I, F)
    A - L'alphabet de travail
    Q - L'ensemble d'Ã©tats
    ğ›¿ - L'ensemble de transitions, ğ›¿ âŠ† Q x A x Q
    I - L'ensemble d'Ã©tats initiaux, I âŠ† Q
    F - L'ensemble d'Ã©tats finaux/acceptants, F âŠ† Q

Une transition peut se reprÃ©senter de plusieurs faÃ§ons:
    - Triplet (Ex: (1, a, 2) avec 1, 2âˆˆQ et aâˆˆA)
    - Couple  (Ex: ((1, a), 2))
    - FlÃ¨che orientÃ©e (1 --a-> 2)

M = { A = { a, b }, Q = { 1, 2, 3 }, I = { 1 }, F = { 2 } }
                  `
                 /
---> 1 ---a--> 2 -\
      `       /  \b
      a,b    /
        \   b
         \ ,
          3

ğ›¿ = { (1, a, 2), (2, b, 2), (2, b, 3), (3, a, 1), (3, b, 1) }
Un AF peut se reprÃ©senter de faÃ§on canonique sans la forme d'un graphe orientÃ© Ã©tiquetÃ©


Mots et langages acceptÃ©s par un AF

Un calcul (ou un run) d'un AF sur un mot a1a2...au (oÃ¹ a1...au âˆˆ A) est un chemin formÃ© de transitions consÃ©cutives qui part d'un Ã©tat initial de l'AF
    1 --a-> 2                 calcul sur le mot "a"
    1 --a-> 2 --b-> 2 --b-> 2 calcul sur le mot "abb"
    1 ou 1 --Æ-> 1            calcul sur le mot Æ
Un calcul acceptant est un calcul qui termine dans un Ã©tat final
Un mot acceptÃ© (reconnu) par un AF est un mot pour lequel il existe au moins un calcul acceptant sur ce mot
    Le mot "abb" est un mot acceptÃ© (reconnu) par l'AF M
    Le mot "aa" n'est pas un mot acceptÃ© par l'AF M


Automates et matrices d'adjacences de graphes

On peut associer de faÃ§on canonique Ã  un automate la matrice d'adjacence du graphe respectif.
Mots de longueur k reconnus par l'AF
    Si on part d'un Ã©tat iâˆˆQ et on arrive dans un Ã©tat jâˆˆQ, M^k(ij)

Le langage acceptÃ©/reconnu par un automate H est l'ensemble des mots acceptÃ©s par l'automate H
    Notation: L(H) est le langage acceptÃ© par l'automate H
        L(M) = a(b + b(a + b)a)*
        Remarque: Il existe des algorithmes qui permettent d'exprimer Ã  l'aide d'une expressions rationnelle le langage acceptÃ© par un AF


Construction d'automates

Exercice: Construire un AF qui permet de reconnaÃ®tre les langages suivants sur l'alphabet A = { a, b }
1) L'ensemble des mots commenÃ§ant par "a"
2) L'ensemble des mots contenant "aba"
3) L'ensemble des mots qui contient un nombre pair de "a"
4) L'ensemble des mots qui ne contient ni "aa" ni "bb"

1) M1 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
   ğ›¿ = { (1, a, 2), (2, (a,b), 2) }
2) M2 = { A = { a, b }, Q = { 1, 2, 3, 4 }, I = { 1 }, F = { 4 } }
   ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, b, 3), (3, a, 4), (4, (a,b), 4) }
3) M3 = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 1 } }
   ğ›¿ = { (1, a, 2), (1, b, 1), (2, b, 2), (2, a, 1) }
4) M4 = { A = { a, b }, Q = { 1, 2 }, I = { 1, 2 }, F = { 1, 2 } }
   ğ›¿ = { (1, a, 2), (2, b, 1) }

Automate sur l'alphabet Ã  10 lettres A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } qui reconnaÃ®t les nombres divisibles par 5
M4 = { A = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, Q = { 1, 2 }, I = { 1 }, F = { 2 } }
ğ›¿ = { (1, (0,1,2,3,4,5,6,7,8,9), 1), (1, (0,5), 2) }



AUTOMATE COMPLET

DÃ©finition: Un AF H = (A, Q, I, F, ğ›¿) est un automate complet si pour chaque Ã©tat qâˆˆQ et pour chaque lettre aâˆˆA, il existe au moins une transition Ã©tiquetÃ©e par a sortant de l'Ã©tat q


Construction d'un automate complet (le complÃ©tÃ©)

ThÃ©orÃ¨me: Si H = (A, Q, I, F, ğ›¿) et soit J = (A, Q âˆª { q1 }, I, F, ğ›¿') oÃ¹:
    q1 est un nouveau Ã©tat (Ã©tat puit?)
    Les transitions de J sont donnÃ©es par ğ›¿' = ğ›¿ âˆª { (p, Î±, q1) } pâˆˆQ, Î±âˆˆA et il n'y a pas de transition de la forme (p, Î±, q) dans H [A completer...?]
L'AF J est un automate complet et L(H) = L(J)
J est le complÃ©tÃ© de H

Preuve: ImmÃ©diate, car les transitions rajoutÃ©es ne modifient pas les chemins associÃ©s aux mots reconnus



AUTOMATES DETERMINISTES

DÃ©finition: L'automate H = (A, Q, I, F, ğ›¿) est un AF dÃ©terministe (ou AFD) si:
    |I| = 1 (il existe un seul Ã©tat initial)
    Pour tout pâˆˆQ et toute Î±âˆˆA, il existe au plus une transition Ã©tiquetÃ©e Î± qui soit de l'Ã©tat p.


Le complÃ©mentaire

DÃ©finition: Le complÃ©mentaire (ou le complÃ©ment) d'un ensemble de mots L âŠ† A* est l'ensemble A* \ L (l'ensemble de mots qui ne sont pas dans L)

ThÃ©orÃ¨me: Soit H = (A, Q, I, F, ğ›¿) un automate complet et dÃ©terministe. Soit J = (A, Q, I, Q \ F, ğ›¿) (J est obtenu Ã  partir de H en rendant finaux les Ã©tats non-finaux de H)
Alors, L(J) = A* \ L(H)

Exemple: H = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, a, 2), (2, a, 2) } } - L(H) = aa* = a+
         J = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, a, 2), (2, a, 2) } } - L(J) = { Æ } = A* \ L(H)

Remarque: Si A n'est pas complet et dÃ©terministe, le thÃ©orÃ¨me n'est pas vrai

Exemples:
    Automate complet mais pas dÃ©terministe:
        H = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, (a,b), 2) } } - L(H) = (a + b)* a (a + b*)
        J = { A = { a, b }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, (a,b), 1), (1, a, 2), (2, (a,b), 2) } } - L(J) = (a + b)* = A* â‰  A* \ L(H)
    Automate dÃ©terministe mais pas complet:
        H = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 2 }, ğ›¿ = { (1, a, 2) } - L(H) = a
        J = { A = { a }, Q = { 1, 2 }, I = { 1 }, F = { 1 }, ğ›¿ = { (1, a, 2) } - L(J) = { Æ } â‰  A* \ L(H)

Remarque: Il ne faut pas confondre complÃ©menter et complÃ©ter



DETERMINISATION DES AUTOMATES

Objectif: A partir d'un AF non-dÃ©terministe H, construire un automate dÃ©terministe J tel que L(A) = L(B)


RÃ©sultat prÃ©liminaire - ensemble de sous-ensembles

Soit Q un ensemble fini, |Q| = n. On note 2^Q l'ensemble de sous-ensembles de Q. Alors |2^Q| = 2^n
Q = { q1, q2,... qn }  2^Q = { âˆ…, { q1 }, { q2 }, ..., { qn }, { q1, q2 }, { q1, q3 }, ..., { qn-1, qn }, ..., { q1, q2, ..., qn } }
Si n = 3, 2^Q = { âˆ…, { q1 }, { q2 }, { q3 }, { q1, q2 }, { q1, q3 }, { q2, q3 }, { q1, q2, q3 } }
|2^Q| = 2^3 = 8

Preuve: |2^Q| = (n 0) + (n 1) + ... (n n) = 2^n oÃ¹ (n k) = (n!) / (k!(n-k)!)


La mÃ©thode de sous-ensembles

ThÃ©orÃ¨me: Soit H = (A, Q, I, F, ğ›¿) un AF non-dÃ©terministe
On construit l'automate pour lequel:
    l'ensemble d'Ã©tats est 2^Q
    l'Ã©tat initial est { I }
    un Ã©tat Pâˆˆ2^Q est final si et seulement si P âˆ© F â‰  âˆ…
    la fonction de transition est donnÃ©e par ğ›¿J(P, a) = U(pâˆˆP) ğ›¿(p, a), âˆ€Pâˆˆ2^Q, aâˆˆA
ThÃ©orÃ¨me: L'AF construit ainsi est un AFD qui reconnait le mÃªme langage que A

Exemple: H = { A = { a, b }, Q = { p, q, r }, I = { p }, F = { r }, ğ›¿ = { (p, (a,b), p), (p, a, q), (q, b, r), (r, (a,b), r) } }
    Q = { p, q, r }
    Les sous-ensembles de Q QJ = { âˆ…, { p }, { q }, { r }, { p, q }, { p, r }, { q, r }, { p, q, r } }
    IJ = { p }
    FJ = { { r }, { p, r }, { q, r }, { p, q, r } }
    ğ›¿J({ p }, a) = ğ›¿H(p, a) = { p, q }
    ğ›¿J({ p }, b) = ğ›¿H(p, b) = { p }
    ğ›¿J({ q }, a) = ğ›¿H(q, a) = âˆ…
    ğ›¿J({ q }, b) = ğ›¿H(q, b) = { r }
    ğ›¿J({ r }, a) = ğ›¿H(r, a) = { r }
    ğ›¿J({ r }, b) = ğ›¿H(r, b) = { r }
    ğ›¿J({ p, q }, a) = ğ›¿H(p, a) U ğ›¿H(q, a) = { p, q } U âˆ…    = { p, q }
    ğ›¿J({ p, q }, b) = ğ›¿H(p, b) U ğ›¿H(q, b) = { p } U { r }    = { p, r }
    ğ›¿J({ q, r }, a) = ğ›¿H(q, a) U ğ›¿H(r, a) = âˆ… U { r }       = { r }
    ğ›¿J({ q, r }, b) = ğ›¿H(q, b) U ğ›¿H(r, b) = { r } U { r }    = { r }
    ğ›¿J({ p, r }, a) = ğ›¿H(p, a) U ğ›¿H(r, a) = { p, q } U { r } = { p, q, r }
    ğ›¿J({ p, r }, b) = ğ›¿H(p, b) U ğ›¿H(r, b) = { p } U { r }    = { p, r }
    ğ›¿J({ p, q, r }, a) = ğ›¿H(p, a) U ğ›¿H(q, a) U ğ›¿H(r, a) = { p, q } U âˆ… U { r } = { p, q, r }
    ğ›¿J({ p, q, r }, b) = ğ›¿H(p, b) U ğ›¿H(q, b) U ğ›¿H(r, b) = { p } U { r } U { r } = { p, r }
    [VOIR SCHEMA]

Preuve: L'AF J est dÃ©terministe et complet par construction.
    RÃ©-Ã©criture de transitions dans J
    P, RâŠ‚Q, aâˆˆA on a P--a->R lorsque R = { qâˆˆQ | âˆƒpâˆˆP, (p, a, q)âˆˆğ›¿H }

Lemme: Pour tout mot w et pour tout Ã©tat râˆˆQ, il existe un chemin q--w->r dans H avec qâˆˆI
    si et seulement s'il existe un chemin I--w->R dans J, avec râˆˆR
    L(H) = L(J) <=> L(H)âŠ†L(J) et L(J)âŠ†L(H) (tout mot de L(H) est tout mot de L(J))
    Soit wâˆˆL(H), il existe un chemin acceptant dans H sur w, c'est Ã  dire âˆƒqâˆˆI et râˆˆF tel que q--w->r dans H

D'aprÃ¨s le lemme, il existe un chemin I--w->R dans J, avec râˆˆR mais râˆˆF => Râˆ©Fâ‰ âˆ… => R Ã©tat final de J
    => I--w->R est un chemin acceptant
    => wâˆˆL(J), âˆ€w
    => L(H)âŠ†L(J)
    => L(J)âŠ†L(H)

Soit wâˆˆL(J)
    => Il existe un chemin acceptant dans J sur w
    C'est Ã  dire âˆƒ I--w->R dans J, R Ã©tat final
        => âˆƒrâˆˆF tel que râˆˆR (car Râˆ©Fâ‰ âˆ…)

D'aprÃ¨s le lemme, il existe un calcul q--w->r dans H, avec qâˆˆI
    => wâˆˆL(H), âˆ€w
    => L(J)âŠ†L(H)
    => L(H) = L(J)


PropriÃ©tÃ©s de clotures des AF

DÃ©finition: Un langage reconnaissable est un langage pour lequel il existe un AF qui reconnaÃ®t ce langage

ThÃ©orÃ¨me: Soit A un alphabet
    - Si L âŠ† A* est un langage reconnaissable alors son complÃ©mentaire A*\L est aussi reconnaissable
    - Si L1 et L2 sont des langages reconnaissables, alors les langages L1âˆªL2 et L1âˆ©L2 sont aussi reconnaissables